.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "C DERSI"  "" ""
.SH NAME
C Dersi \- 
.sp
Bu derste C programlama dersi anlatılacaktır.
Bu dersin düzgünce anlaşılabilmesi için temel düzey gnu/linux bilmeniz gerekmektedir.
.SH DERLEME IŞLEMI
.sp
\fBC\fP derlemeli bir programlama dilidir.
Yani yazılan kodun derleneek bilgisayarın anlayacağı hale getirilmesi gerekmektedir.
Derleme işlemini \fBgcc\fP veya \fBclang\fP kullanarak yapabiliriz.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# koddan .o dosyası üretelim
$ gcc \-c main.c
# .o dosyasından derlenmiş dosya üretelim.
$ gcc \-o main main.o
# kodu çalıştıralım
$ \&./main
\-> Hello World
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte öncelikle \fB\&.o\fP uzantılı object dosyamızı ürettik.
Bu dosya kodun derlenmiş fakat henüz kullanıma hazır hale getirilmemiş halidir.
Bu sebeple \fB\&.o\fP dosyalarını linkleme işleminden geçirerek son halini almasını sağlamalıyız.
.sp
\fBNot:\fP derleyicimiz \fB\&.o\fP üretmeden de doğrudan derleme yapabilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o main main.c
.ft P
.fi
.UNINDENT
.UNINDENT
.SH AÇIKLAMA SATIRI
.sp
C kodlarında 3 farklı yolla girintileme yapılabilir.
.INDENT 0.0
.IP 1. 3
\fB//\fP kullanarak satırın geri kalanını açıklama satırı yapabiliriz.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// bu bir açıklama satırıdır.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fB/*\fP ile başlayıp \fB*/\fP ile biten alanlar açıklamadır.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* Bu
   bir
   açıklama
   satırıdır */
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 3. 3
\fB#if 0\fP ile başlayan satırdan \fB#endif\fP satırına kadar olan kısım açıklama satırıdır.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#if 0
bu bir
açıklama
satırıdır
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SH GIRINTILEME
.sp
C programlama dilinde blocklar \fB{}\fP karakterleri ile belirtilir.
Kodun okunalı olması için girintilenmesi gereklidir fakat şart değildir.
Girintileme için 4 boşluk veya 1 tab kullanabilirsiniz.
.sp
Bir block aşağdaki gibi bir yapıya sahiptir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
aaaa (bbbb) {
        cccc;
  ddd;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Her satırın sonunda ; işareti bulunmalıdır.
.SH İLK PROGRAM
.sp
C programları çalıştırıldığında \fBmain\fP fonsiyonu çalıştırılır.
Aşağıda örnek main fonksiyonu bulunmaktadır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int main(int argc, char** argv) {
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBint main\fP kısmında  int döndürülecek değer türü main adıdır.
.IP \(bu 2
\fBint argc\fP parametre sayısını belirtir.
.IP \(bu 2
\fBchar **argv\fP parametre listesini belirtir.
.IP \(bu 2
\fBreturn 0\fP komutu 0 ile çıkış yapar.
.UNINDENT
.sp
Burada \fBmain\fP fonksiyonunu türünün bir önemi yoktur. \fBvoid\fP olarak da tanımlanabilir. Ayrıca kullanmayacaksak arguman tanımlamaya da gerek yoktur. Kısaca Şu şekilde de yazabilirdik.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void main(){}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH EKRANA YAZI YAZMA
.sp
Öncelikle \fBstdio.h\fP kütüphanesine ihtiyacimiz olduğu için onu eklemeliyiz.
Ardından \fBprintf\fP fonksiyonu ile ekrana yazı yazabiliriz.
.sp
\fBprintf\fP fonksiyonunun 1. parametresi yazdirma şablonunu diğerleri ise yazdırılacak verileri belirtir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>

int main(int argc, char** argv) {
    printf(\(dq%s\en\(dq, \(dqMerhaba Dünya!\(dq);
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBinclude\fP ile belirttiğimiz dosyalar sistemde \fB/usr/include\fP içerisinde bulunur.
.IP \(bu 2
\fBprintf\fP fonksiyonundaki \fB%s\fP yazılar için, \fB%c\fP karakterler için, \fB%d\fP sayılar için kullanılır.
.UNINDENT
.SH DEĞIŞKENLER
.sp
C dilinde değişkenler aşağıdaki gibi tanımlanır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&...
int sayi = 12;
char* yazi = \(dqtest\(dq;
char karakter = \(aqc\(aq;
float sayi2 = 12.42;
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Bununla birlikte \fB#define\fP kullanarak derlemeden önce koddaki alanların karşılığı ile değiştirilmesini sağlayabilirsiniz.
Bu şekilde tanımlanan değerler derlemeden önce yerine yazıldığı için değişken olarak işlem görmezler.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#define sayi 12
\&...
printf(\(dq%d\en\(dq,sayi);
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DIZILER
.sp
Diziler iki şekilde tanımlanabilir.
.sp
1. Pointer kullanarak tanımlanabilir. Bu konunun detaylarına ilerleyen kısımda değinilecektir.
Bu şekilde tanımlanan dizilerde başta uzunluk belirtilmek zorunda değildir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {12, 22, 31};
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
Uzunluk belirterek tanımlanabilir. Bu şekilde tanımlanan dizilerin uzunluğu sabittir.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int dizi[3] = {12, 22, 31};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
C dilinde string kavramı bulunmaz. Onun yerine karakter dizileri kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
char *txt = \(dqdeneme123\(dq;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Dizinin bir elemanına erişmek için aşağıdaki gibi bir yol kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {12, 22, 31};
int c = dizi[1]; // dizinin 2. elemanı
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Dizi indisleri 0dan başlar.
.sp
Bir dizinin uzunluğunu dizinin bellekteki boyutunu birim boyutuna bölerek buluruz.
Bunun  için \fBsizeof\fP fonksiyonu kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {11, 22, 31};
int l = sizeof(dizi) / sizeof(int);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH KLAVYEDEN DEĞER ALMA
.sp
Klavyeden değer almak için \fBscanf\fP kullanılır. İlk parameter şablonu diğerleri ise değişkenlerin bellek adresini belirtir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int sayi;
scanf(\(dq%d\en\(dq, &sayi);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Bu şekilde değer alma yaptığımızda formata uygun olmayan şekilde değer girilebilir.
Eğer böyle bir durum oluşursa değişken \fBNULL\fP olarak atanır. yani değeri bulunmaz.
Buda kodun işleyişinde soruna yol açabilir. Bu yüzden değişkeni kullanmadan ince \fBNULL\fP olup olmadığını kontrol etmelisiniz.
.SH KOŞULLAR
.sp
Koşullar için \fBif\fP bloğu kullanılır. Block içindeki ifade \fB0\fP veya \fBNULL\fP olursa koşul sağlanmaz. Bu durumda varse \fBelse\fP bloğu çalıştırılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (koşul1) {
    block 1
} else if (koşul2) {
  block 2
} else {
  block 3
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Örnek olarak girilen sayının çift olup olmadığını yazan uygulama yazalım.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>

int main(int argc, char** argv) {
    int sayi;
    scanf(\(dq%d\(dq,&sayi);
    if (sayi == NULL) {
        printf(\(dq%s\en\(dq, \(dqGeçersiz sayı girdiniz.\(dq);
    } else if(sayi % 2) {
        printf(\(dq%d tektir.\en\(dq, sayi);
    } else {
        printf(\(dq%d çifttir.\en\(dq, sayi);
    }
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada \fB%\fP operatörü 2 ile bölümden kalanı bulmaya yarar.
Sayı tek ise 1 değilse 0 sonucu elde edilir.
Bu sayede tek sayılar için koşul sağlanır çift sayılar için sağlanmaz.
.sp
Tek satırdan oluşan koşullarda \fB{}\fP kullanmaya gerek yoktur.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (i < 32)
  printf(\(dq%s\en\(dq,\(dq32den küçüktür\(dq);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Koşul ifadeleri aşağıdaki gibi listelenebilir.
.SH KOŞUL IŞLEYICILERI
.TS
center;
|l|l|l|.
_
T{
ifade
T}	T{
anlamı
T}	T{
örnek
T}
_
T{
>
T}	T{
büyüktür
T}	T{
121 > 12
T}
_
T{
<
T}	T{
küçüktür
T}	T{
12 < 121
T}
_
T{
==
T}	T{
birbirine eşittir
T}	T{
121 == 121
T}
_
T{
!
T}	T{
karşıtlık bildirir.
T}	T{
!(12 > 121)
T}
_
T{
&&
T}	T{
logic and
T}	T{
\(dqfg\(dq == \(dqaa\(dq && 121 > 12
T}
_
T{
||
T}	T{
logic or
T}	T{
\(dqfg\(dq == \(dqaa\(dq || 121 > 12
T}
_
T{
!=
T}	T{
eşit değildir
T}	T{
\(dqfg\(dq != \(dqaa\(dq
T}
_
T{
>=
T}	T{
büyük eşittir
T}	T{
121 >= 121
T}
_
T{
<=
T}	T{
küçük eşittir
T}	T{
12 <= 12
T}
_
.TE
.SH SWITCH - CASE
.sp
Bir sayıya karşılık bir işlem yapmak için \fBswitch \- case\fP yapısı kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
      switch(sayi) {
        1:
          // sayı 1se burası çalışır.
          // break olmadığı için alttan devam eder.
        2:
          // sayı 1 veya 2 ise burası çalışır.
          break;
        3:
          // sayı 3 ise burası çalışır.
        default:
          // sayı eşleşmezse burası çalışır.
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DÖNGÜLER
.sp
Döngüler koşullara benzer fakat döngülerde koşul sağlanmayana kadar block içi tekrarlanır.
Döngü oluşturmak için \fBwhile\fP kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i=10;
while(i<0){
    printf(\(dq%d\en\(dq, i);
    i\-\-;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte 10dan 0a kadar geri sayan örnek verilmiştir.
En son i değişkeni 0 olduğunda koşul sağlanmadığı için döngü sonlanır.
.sp
Aynı işlemi \fBfor\fP ifadesi ile de yapabiliriz.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for(int i=10;i<0;i\-\-){
    printf(\(dq%d\en\(dq, i);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada for içerisinde 3 bölüm bulunur.
İlkinde değer atanır.
İkincinde koşul yer alır.
Üçüncüsünde değişkene yapılacak işlem belirtilir.
.SH GOTO
.sp
C dilinde kodun içerisindeki bir yere etiket tanımlanıp \fBgoto\fP ile bu etikete gidilebilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yaz:
printf(\(dq%s\en\(dq, \(dqHello World\(dq);
goto yaz;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte sürekli olarak yazı yazdırılır. Bunun sebebi her seferinde \fByaz\fP etiketine gidilmesidir.
.sp
Bundan faydalanarak döngü oluşturulabilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 10;
islem:
if(i < 0){
    printf(\(dq%d\en\(dq,i);
    i\-\-;
    goto islem;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada koşul bloğunun en sonunda tekrar başa dönmesi için \fBgoto\fP kullandık.
.SH FONKSIYONLAR
.sp
C dilinde bir fonksiyon aşağıdaki gibi tanımlanır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int yazdir(char* yazi){
    if(yazi != NULL){
        printf(\(dq%s\en\(dq,yazi);
        return 0;
    }
return 1;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki fonksiyon verilen değişken değere sahipse ekrana yazdırıp 0 döndürür.
Eğer değeri yoksa 1 döndürür.
.sp
Basit işlemler için \fB#define\fP ile de fonksiyon tanımlanabilir.
Bu şekilde tanımlanan fonksiyonlar derleme öncesi yerine yazılarak çalışır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#define topla(A,B) A+B

int main(int argc, char** argv){
    int sayi = topla(3, 5);
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Fonksiyonlar yazılma sırasına göre kullanılabilirler.
Bu yüzden fonksiyonlar henüz tanımlı değilse kullanılamazlar.
Bu durumun üstesinden gelmek için \fBheader\fP tanımlaması yapılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void yaz();
int main(){
    yaz();
    return 0;
}
void yaz(){
    printf(\(dq%s\en\(dq,\(dqHello World\(dq);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Header tanımlamaları kütüphane yazarken de kullanılır.
Bunun için bu tanımlamaları \fB\&.h\fP uzantılı dosyalara yazmanız gereklidir.
Bu dosyayı \fBinclude\fP kullanarak eklemeliyiz.
.sp
yaz.h dosyası
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void yaz();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
main.c dosyası
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include \(dqyaz.h\(dq
#include <stdio.h>

int main(){
    yaz();
    return 0;
}

void yaz(){
    printf(\(dq%s\en\(dq,\(dqHello World\(dq);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP \fBinclude\fP ifadesinde \fB<>\fP içine aldığımız dosyalar \fB/usr/include\fP \fB\(dq\fP içine aldığımız ise mevcut dizinde aranır.
.SH POINTER VE ADDRESS KAVRAMI
.sp
Pointerlar bir değişkenin bellekte bulunduğu yeri belirtir. ve \fB*\fP işareti ile belirtir.
Örneğin aşağıda bir metin pointer olarak tanımlansın ve 2 birim kaydırılsın.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
char* msg = \(dqabcde\(dq;
printf(\(dq%s\en\(dq, msg + sizeof(char)*2 );
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Bura 2 char uzunluğu kadar pointer kaydırıldığı için ekrana ilk iki karakteri silinerek yazdırılmıştır.
.sp
Adres ise bir değişkenin bellek adresini ifade eder. \fB&\fP işareti ile belirtilir. Örneğin rastgele bir değişken oluşturup adresini ekrana yazalım.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 0;
printf(\(dq%p\en\(dq &i);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Konunun daha iyi anlaşılması için bir değişken oluşturup adresini bir pointera kopyalayalım. ve sonra değişkenimizi değiştirelim.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 0; // değişken tanımladık.
int *k = &i; // adresini kopyaladık.
int l = i; // değeri kopyaladık.
i = 1; // değişkeni değiştirdik.
printf(\(dq%d %d\en\(dq, i, *k, l);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Bu örnekte ilk iki değer de değişir fakat üçüncüsü değişmez.
Bunun sebebi ikinci be birinci değişkenlerin adresi aynıyken üçüncü değişkenin adresi farklıdır.
.sp
Bir fonksiyon tanımlarken pointer olarak arguman aldırıp bu değerde değişiklik yapabilir. Buna örnek kullanım olarak \fBscanf\fP fonksiyonu verilebilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>
void topla(int* sonuc, int sayi1, int sayi2){
    *sonuc = sayi1 + sayi2;
}
void main(){
    int i;
    topla(&i, 12, 22);
    printf(\(dq%d\en\(dq,i);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada fonksiyona değişkenin adresi girilir. Fonksiyon bu adrese toplamı yazar. Daha sonra değişkenimizi kullanabilirsiniz.
.\" Generated by docutils manpage writer.
.
