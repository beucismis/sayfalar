.\" Man page generated from reStructuredText.
.
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.TH "C DERSI"  "" ""
.SH NAME
C Dersi \- 
.sp
Bu derste C programlama dersi anlatılacaktır.
Bu dersin düzgünce anlaşılabilmesi için temel düzey gnu/linux bilmeniz gerekmektedir.
.SH DERLEME IŞLEMI
.sp
\fBC\fP derlemeli bir programlama dilidir.
Yani yazılan kodun derleneek bilgisayarın anlayacağı hale getirilmesi gerekmektedir.
Derleme işlemini \fBgcc\fP veya \fBclang\fP kullanarak yapabiliriz.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# koddan .o dosyası üretelim
$ gcc \-c main.c
# .o dosyasından derlenmiş dosya üretelim.
$ gcc \-o main main.o
# kodu çalıştıralım
$ \&./main
\-> Hello World
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte öncelikle \fB\&.o\fP uzantılı object dosyamızı ürettik.
Bu dosya kodun derlenmiş fakat henüz kullanıma hazır hale getirilmemiş halidir.
Bu sebeple \fB\&.o\fP dosyalarını linkleme işleminden geçirerek son halini almasını sağlamalıyız.
.sp
\fBNot:\fP derleyicimiz \fB\&.o\fP üretmeden de doğrudan derleme yapabilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ gcc \-o main main.c
.ft P
.fi
.UNINDENT
.UNINDENT
.SH AÇIKLAMA SATIRI
.sp
C kodlarında 3 farklı yolla girintileme yapılabilir.
.INDENT 0.0
.IP 1. 3
\fB//\fP kullanarak satırın geri kalanını açıklama satırı yapabiliriz.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
// bu bir açıklama satırıdır.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
\fB/*\fP ile başlayıp \fB*/\fP ile biten alanlar açıklamadır.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/* Bu
   bir
   açıklama
   satırıdır */
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 3. 3
\fB#if 0\fP ile başlayan satırdan \fB#endif\fP satırına kadar olan kısım açıklama satırıdır.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#if 0
bu bir
açıklama
satırıdır
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.SH GIRINTILEME
.sp
C programlama dilinde blocklar \fB{}\fP karakterleri ile belirtilir.
Kodun okunalı olması için girintilenmesi gereklidir fakat şart değildir.
Girintileme için 4 boşluk veya 1 tab kullanabilirsiniz.
.sp
Bir block aşağdaki gibi bir yapıya sahiptir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
aaaa (bbbb) {
        cccc;
  ddd;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Her satırın sonunda ; işareti bulunmalıdır.
.SH İLK PROGRAM
.sp
C programları çalıştırıldığında \fBmain\fP fonsiyonu çalıştırılır.
Aşağıda örnek main fonksiyonu bulunmaktadır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int main(int argc, char** argv) {
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBint main\fP kısmında  int döndürülecek derer türü main adıdır.
.IP \(bu 2
\fBint argc\fP parametre sayısını belirtir.
.IP \(bu 2
\fBchar **argv\fP parametre listesini belirtir.
.IP \(bu 2
\fBreturn 0\fP komutu 0 ile çıkış yapar.
.UNINDENT
.SH EKRANA YAZI YAZMA
.sp
Öncelikle \fBstdio.h\fP kütüphanesine ihtiyacimiz olduğu için onu eklemeliyiz.
Ardından \fBprintf\fP fonksiyonu ile ekrana yazı yazabiliriz.
.sp
\fBprintf\fP fonksiyonunun 1. parametresi yazdirma şablonunu diğerleri ise yazdırılacak verileri belirtir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>

int main(int argc, char** argv) {
    printf(\(dq%s\en\(dq, \(dqMerhaba Dünya!\(dq);
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fBinclude\fP ile belirttiğimiz dosyalar sistemde \fB/usr/include\fP içerisinde bulunur.
.IP \(bu 2
\fBprintf\fP fonksiyonundaki \fB%s\fP yazılar için, \fB%c\fP karakterler için, \fB%d\fP sayılar için kullanılır.
.UNINDENT
.SH DEĞIŞKENLER
.sp
C dilinde değişkenler aşağıdaki gibi tanımlanır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&...
int sayi = 12;
char* yazi = \(dqtest\(dq;
char karakter = \(aqc\(aq;
float sayi2 = 12.42;
\&...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Bununla birlikte \fB#define\fP kullanarak derlemeden önce koddaki alanların karşiliği ile değiştirlmasini sağlayabilirsiniz.
Bu şekilde tanımlanan değerler derlemeden önce yerine yazıldığı için değişken olarak işlem görmezler.
\&.. code\-block:: C
.INDENT 0.0
.INDENT 3.5
#define sayi 12
\&...
printf(\(dq%dn\(dq,sayi);
\&...
.UNINDENT
.UNINDENT
.SH DIZILER
.sp
Diziler iki şekilde tanımlanabilir.
.sp
1. Pointer kullanarak tanımlanabilir. Bu konunun detaylarına ilerleyen kısımda değinilecektir.
Bu şekilde tanımlanan dizilerde başta uzunluk belirtilmek zorunda değildir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {12, 22, 31};
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP 2. 3
Uzunluk belirterek tanımlanabilir. Bu şekilde tanımlanan dizilerin uzunluğu sabittir.
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int dizi[3] = {12, 22, 31};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
C dilinde string kavramı bulunmaz. Onun yerine karakter dizileri kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
char *txt = \(dqdeneme123\(dq;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Dizinin bir elemanına erişmek için aşağıdaki gibi bir yol kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {12, 22, 31};
int c = dizi[1]; // dizinin 2. elemanı
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Dizi indisleri 0dan başlar.
.sp
Bir dizinin uzunluğunu dizinin bellekteki boyutunu birim boyutuna bölerek buluruz.
Bunun  için \fBsizeof\fP fonksiyonu kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int *dizi = {11, 22, 31};
int l = sizeof(dizi) / sizeof(int);
.ft P
.fi
.UNINDENT
.UNINDENT
.SH KLAVYEDEN DEĞER ALMA
.sp
Klavyeden değer almak için \fBscanf\fP kullanılır. İlk parameter şablonu diğerleri ise değişkenlerin bellek adresini belirtir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int sayi;
scanf(\(dq%d\en\(dq, &sayi);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNot:\fP Bu şekilde değer alma yaptığımızda formata uygun olmayan şekilde değer girilebilir.
Eğer böyle bir durum oluşursa değişken \fBNULL\fP olarak atanır. yani değeri bulunmaz.
Buda kodun işleyişinde soruna yol açabilir. Bu yüzden değişkeni kullanmadan ince \fBNULL\fP olup olmadığını kontrol etmelisiniz.
.SH KOŞULLAR
.sp
Koşullar için \fBif\fP bloğu kullanılır. Block içindeki ifade \fB0\fP veya \fBNULL\fP olursa koşul sağlanmaz. Bu durumda varse \fBelse\fP bloğu çalıştırılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (koşul1) {
    block 1
} else if (koşul2) {
  block 2
} else {
  block 3
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Örnek olarak girilen sayının çift olup olmadığını yazan uygulama yazalım.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <stdio.h>

int main(int argc, char** argv) {
    int sayi;
    scanf(\(dq%d\(dq,&sayi);
    if (sayi == NULL) {
        printf(\(dq%s\en\(dq, \(dqGeçersiz sayı girdiniz.\(dq);
    } else if(sayi % 2) {
        printf(\(dq%d tektir.\en\(dq, sayi);
    } else {
        printf(\(dq%d çifttir.\en\(dq, sayi);
    }
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada \fB%\fP operatörü 2 ile bölümden kalanı bulmaya yarar.
Sayı tek ise 1 değilse 0 sonucu elde edilir.
Bu sayede tek sayılar için koşul sağlanır çift sayılar için sağlanmaz.
.sp
Tek satırdan oluşan koşullarda \fB{}\fP kullanmaya gerek yoktur.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
if (i < 32)
  printf(\(dq%s\en\(dq,\(dq32den küçüktür\(dq);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Koşul ifadeleri aşağıdaki gibi listelenebilir.
.SH KOŞUL IŞLEYICILERI
.TS
center;
|l|l|l|.
_
T{
ifade
T}	T{
anlamı
T}	T{
örnek
T}
_
T{
>
T}	T{
büyüktür
T}	T{
121 > 12
T}
_
T{
<
T}	T{
küçüktür
T}	T{
12 < 121
T}
_
T{
==
T}	T{
birbirine eşittir
T}	T{
121 == 121
T}
_
T{
!
T}	T{
karşıtlık bildirir.
T}	T{
!(12 > 121)
T}
_
T{
&&
T}	T{
logic and
T}	T{
\(dqfg\(dq == \(dqaa\(dq && 121 > 12
T}
_
T{
||
T}	T{
logic or
T}	T{
\(dqfg\(dq == \(dqaa\(dq || 121 > 12
T}
_
T{
!=
T}	T{
eşit değildir
T}	T{
\(dqfg\(dq != \(dqaa\(dq
T}
_
T{
>=
T}	T{
büyük eşittir
T}	T{
121 >= 121
T}
_
T{
<=
T}	T{
küçük eşittir
T}	T{
12 <= 12
T}
_
.TE
.SH SWITCH - CASE
.sp
Bir sayıya karşılık bir işlem yapmak için \fBswitch \- case\fP yapısı kullanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
      switch(sayi) {
        1:
          // sayı 1se burası çalışır.
          // break olmadığı için alttan devam eder.
        2:
          // sayı 1 veya 2 ise burası çalışır.
          break;
        3:
          // sayı 3 ise burası çalışır.
        default:
          // sayı eşleşmezse burası çalışır.
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DÖNGÜLER
.sp
Döngüler koşullara benzer fakat döngülerde koşula sağlanmayana kadar block içi tekrarlanır.
Döngü oluşturmak için \fBwhile\fP kıllanılır.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i=10;
while(i<0){
    printf(\(dq%d\en\(dq, i);
    i\-\-;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte 10dan 0a kadar geri sayan örnek verilmiştir.
En son i değişkeni 0 olduğunda koşul sağlanmadığı için döngü sonlanır.
.sp
Aynı işlemi \fBfor\fP ifadesi ile de yapabiliriz.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
for(int i=10;i<0;i\-\-){
    printf(\(dq%d\en\(dq, i);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada for içerisinde 3 bölüm bulunur.
İlkinde değer atanır.
İkincinde koşul yer alır.
Üçüncüsünde değişkene yapılacak işlem belirtilir.
.SH GOTO
.sp
C dilinde kodun içerisindeki bir yere etiket tanımlanıp \fBgoto\fP ile bu etikete gidilebilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yaz:
printf(\(dq%s\en\(dq, \(dqHello World\(dq);
goto yaz;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Yukarıdaki örnekte sürekli olarak yazı yazdırılır. Bunun sebebi her seferinde \fByaz\fP etiketine gidilmesidir.
.sp
Bundan faydalanarak döngü oluşturulabilir.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 10;
islem:
if(i < 0){
    printf(\(dq%d\en\(dq,i);
    i\-\-;
    goto islem;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Burada koşul bloğunun en sonunda tekrar başa dönmesi için \fBgoto\fP kullandık.
.\" Generated by docutils manpage writer.
.
